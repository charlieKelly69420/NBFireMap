name: Fetch NB Fire Feeds

on:
  schedule:
    - cron: "38 * * * *"
  workflow_dispatch:
permissions:
  contents: write

jobs:
  fetch:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repo
        uses: actions/checkout@v4

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Fetch and verify feeds (10-in-a-row, up to 5 passes, 2s per copy, 30s between passes)
        id: fetch
        env:
          BASE: https://gis-erd-der.gnb.ca/arcgis/rest/services/Fire_Dashboards/Public_Fires/MapServer
          # IMPORTANT: ask for GeoJSON in WGS84 (CRS84 lon/lat) so GitHub can render it.
          QUERY_GEO: '?where=1%3D1&outFields=*&outSR=4326&f=geojson'
          QUERY_JSON: '?where=1%3D1&outFields=*&f=json'
          TABLE_NAME: SDEOWNER.V_FIRE_DASHBOARD_SUM
          COPIES: "10"
        run: |
          set -euo pipefail

          cleanup_prefix() { rm -f "${1}"[0-9][0-9].json "${1}"[0-9][0-9].geojson || true; }

          download_n() {
            local url="$1" prefix="$2" n="${3:-10}"
            cleanup_prefix "$prefix"
            for i in $(seq -w 01 "$n"); do
              tmpfile="$(mktemp)"
              if ! curl -sS --fail --retry 3 --retry-delay 2 --retry-connrefused --max-time 60 "$url" -o "$tmpfile"; then
                echo "Curl failed for ${url}"
                rm -f "$tmpfile"
                return 1
              fi
              if ! jq -e type "$tmpfile" >/dev/null 2>&1; then
                echo "Invalid JSON for ${url}"
                rm -f "$tmpfile"
                return 1
              fi
              ext="${prefix##*.}" # keep extension in prefix if provided
              [ "$ext" = "geojson" ] || ext="json"
              mv "$tmpfile" "${prefix%.*}${i}.${ext}"
              sleep 2
            done
          }

          all_match() {
            local prefix="$1"
            ls ${prefix%.*}[0-9][0-9].* >/dev/null 2>&1 || return 1
            local uniq_count
            uniq_count=$(sha256sum ${prefix%.*}[0-9][0-9].* | awk '{print $1}' | sort | uniq | wc -l | tr -d ' ')
            test "$uniq_count" -eq 1
          }

          get_table_id() {
            local meta
            if ! meta="$(curl -sS --fail "$BASE?f=pjson")"; then
              echo "Failed to read service metadata"; return 1
            fi
            echo "$meta" | jq -e --arg NAME "$TABLE_NAME" '.tables[] | select(.name==$NAME) | .id' 2>/dev/null | tr -d '\r\n'
          }

          # Add timestamp to either GeoJSON (properties) or Esri JSON (attributes)
          write_with_timestamp() {
            local src="$1" dest="$2"
            local ts; ts="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
            jq --arg ts "$ts" '
              if .type=="FeatureCollection" and (.features|type)=="array" then
                .features |= map(.properties |= ((. // {}) + {"UPDATED_FROM_ERD": $ts}))
              elif (.features|type)=="array" then
                .features |= map(.attributes |= ((. // {}) + {"UPDATED_FROM_ERD": $ts}))
              else . end
            ' "$src" > "${dest}.tmp"
            mv "${dest}.tmp" "$dest"
          }

          ACTIVE_NEEDED=true
          OUT_NEEDED=true
          TABLE_NEEDED=true

          TID="$(get_table_id || true)"
          if [ -z "${TID:-}" ]; then
            echo "Could not find table id for $TABLE_NAME in service metadata."
            TABLE_NEEDED=false
          fi

          ANY_CHANGED=false

          for pass in 1 2 3 4 5; do
            echo "::group::Pass $pass"

            if [ "$ACTIVE_NEEDED" = true ]; then
              echo "Attempt: active fires (layer 0) -> GeoJSON"
              if download_n "$BASE/0/query$QUERY_GEO" "active_fires.geojson" "$COPIES"; then
                if all_match "active_fires.geojson"; then
                  write_with_timestamp active_fires01.geojson active_fires.geojson
                  echo "Active fires stabilized on pass $pass"
                  ACTIVE_NEEDED=false
                  ANY_CHANGED=true
                else
                  echo "Active fires NOT stable on pass $pass."
                fi
              else
                echo "Active fires download failed on pass $pass."
              fi
              cleanup_prefix "active_fires.geojson"
            fi

            if [ "$OUT_NEEDED" = true ]; then
              echo "Attempt: out fires (layer 1) -> GeoJSON"
              if download_n "$BASE/1/query$QUERY_GEO" "out_fires.geojson" "$COPIES"; then
                if all_match "out_fires.geojson"; then
                  write_with_timestamp out_fires01.geojson out_fires.geojson
                  echo "Out fires stabilized on pass $pass"
                  OUT_NEEDED=false
                  ANY_CHANGED=true
                else
                  echo "Out fires NOT stable on pass $pass."
                fi
              else
                echo "Out fires download failed on pass $pass."
              fi
              cleanup_prefix "out_fires.geojson"
            fi

            if [ "$TABLE_NEEDED" = true ]; then
              echo "Attempt: table $TABLE_NAME (id=${TID:-unknown}) -> JSON (non-spatial)"
              if [ -n "${TID:-}" ]; then
                if download_n "$BASE/$TID/query$QUERY_JSON" "v_fire_dashboard_sum.json" "$COPIES";_
