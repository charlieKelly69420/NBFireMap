name: Daily Fire Data Archive

on:
  schedule:
    - cron: "10 9 * * *"   # daily
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: fire-archive-${{ github.ref }}
  cancel-in-progress: false

jobs:
  fetch-and-archive:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          set -xeuo pipefail
          python -m pip install --upgrade pip
          pip install geopandas requests

      - name: Download, validate (5× copies), clip, and write files (verbose)
        env:
          PYTHONUNBUFFERED: "1"        # unbuffered logs
        shell: bash
        run: |
          set -xeuo pipefail
          python -u <<'PYCODE'
          import os, sys, time, json
          from datetime import datetime
          from zoneinfo import ZoneInfo

          import requests
          import geopandas as gpd
          from shapely.geometry import box

          def log(msg): print(msg, flush=True)

          # --- Date / output ---
          TZ = ZoneInfo("America/Toronto")
          today_str = datetime.now(TZ).strftime("%Y%m%d")

          ROOT = "archive"
          FOLDERS = {"cwfis": os.path.join(ROOT, "cwfis"),
                     "erd":   os.path.join(ROOT, "erd")}
          for p in FOLDERS.values():
              os.makedirs(p, exist_ok=True)

          # --- New Brunswick bbox (WGS84) ---
          NB_BBOX = (-69.05, 44.56, -63.70, 48.07)  # minx, miny, maxx, maxy
          log(f"[CFG] NB_BBOX={NB_BBOX}")
          nb_poly = box(*NB_BBOX)
          nb_gdf = gpd.GeoDataFrame(geometry=[nb_poly], crs="EPSG:4326")

          # --- HTTP session ---
          S = requests.Session()
          S.headers.update({
              "User-Agent": "nb-fire-archive/1.1 (github actions)",
              "Accept": "application/json, application/geo+json;q=0.9, */*;q=0.8",
          })
          TIMEOUT=90

          # ---------- Builders (server-side NB filter) ----------
          # CWFIS — WFS with bbox filter; fallback to CQL if needed.
          def cwfis_builder(type_name: str):
              base = "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/ows"
              bbox = f"{NB_BBOX[0]},{NB_BBOX[1]},{NB_BBOX[2]},{NB_BBOX[3]},EPSG:4326"
              params_bbox = {
                  "service": "WFS", "version": "1.0.0", "request": "GetFeature",
                  "typeName": type_name, "srsName": "EPSG:4326",
                  "bbox": bbox, "outputFormat": "application/json",
              }
              # Fallback using CQL_FILTER=BBOX(the_geom,...) (some GeoServer setups prefer this)
              params_cql = {
                  "service": "WFS", "version": "1.0.0", "request": "GetFeature",
                  "typeName": type_name, "srsName": "EPSG:4326",
                  "CQL_FILTER": f"BBOX(the_geom,{NB_BBOX[0]},{NB_BBOX[1]},{NB_BBOX[2]},{NB_BBOX[3]})",
                  "outputFormat": "application/json",
              }
              return ("CWFIS", base, [params_bbox, params_cql])

          # ERD — ArcGIS REST with envelope (inSR=4326); fallback to no-geometry.
          def erd_builder(layer_idx: int):
              base = f"https://gis-erd-der.gnb.ca/arcgis/rest/services/Fire_Dashboards/Public_Fires/MapServer/{layer_idx}/query"
              params_env = {
                  "where": "1=1",
                  "geometryType": "esriGeometryEnvelope",
                  "geometry": f"{NB_BBOX[0]},{NB_BBOX[1]},{NB_BBOX[2]},{NB_BBOX[3]}",
                  "inSR": 4326,
                  "spatialRel": "esriSpatialRelIntersects",
                  "outFields": "*",
                  "returnGeometry": "true",
                  "outSR": 4326,
                  "f": "geojson",
                  # pagination-friendly (just in case)
                  "resultRecordCount": 20000,
                  "returnExceededLimitFeatures": "true",
              }
              params_all = {
                  "where": "1=1",
                  "outFields": "*",
                  "returnGeometry": "true",
                  "outSR": 4326,
                  "f": "geojson",
              }
              return ("ERD", base, [params_env, params_all])

          DATASETS = [
              {"key": "24_hour_spots",   "group": "cwfis", "builder": lambda: cwfis_builder("public:hotspots_last24hrs")},
              {"key": "fire_perimeters", "group": "cwfis", "builder": lambda: cwfis_builder("public:m3_polygons_current")},
              {"key": "active_fires",    "group": "erd",   "builder": lambda: erd_builder(0)},
              {"key": "out_fires",       "group": "erd",   "builder": lambda: erd_builder(1)},
          ]

          # ---------- Fetch helpers ----------
          def fetch_once(label, base, params):
              req = S.prepare_request(requests.Request("GET", base, params=params))
              log(f"[REQ] {label}: {req.method} {req.url}")
              r = S.send(req, timeout=TIMEOUT)
              log(f"[RES] {label}: status={r.status_code} type={r.headers.get('content-type')} bytes={len(r.content)}")
              r.raise_for_status()
              # If not JSON, dump head of body for diagnostics
              ctype = (r.headers.get('content-type') or '').lower()
              if "json" not in ctype:
                  log(f"[WARN] {label}: non-JSON response head:\n{r.text[:300]}")
              obj = r.json()
              if isinstance(obj, dict) and obj.get("error"):
                  raise RuntimeError(f"Server error for {label}: {obj['error']}")
              return obj

          def fetch_geojson_with_fallbacks(source_label, base, params_list):
              """
              Try each params variant until we get features; if all return 0,
              return the last object anyway (so '0 features' is explicit).
              """
              last_obj = None
              for idx, params in enumerate(params_list, 1):
                  obj = fetch_once(f"{source_label} try{idx}", base, params)
                  n = len(obj.get("features", []))
                  log(f"[INFO] {source_label} try{idx}: features={n}")
                  last_obj = obj
                  if n > 0:
                      return obj
              return last_obj

          def to_gdf(obj):
              feats = obj.get("features", [])
              gdf = gpd.GeoDataFrame.from_features(feats, crs="EPSG:4326")
              return gdf

          def clip_to_nb(gdf):
              if gdf.empty:
                  return gdf
              try:
                  gdf = gdf.set_geometry(gdf.geometry.buffer(0))
              except Exception:
                  pass
              return gpd.clip(gdf, nb_gdf)

          def consensus_download(builder, label, max_rounds=5, samples=5):
              for attempt in range(1, max_rounds + 1):
                  counts, frames = [], []
                  log(f"[ROUND] {label}: attempt {attempt}/{max_rounds}")
                  src_label, base, variants = builder()
                  for i in range(samples):
                      obj = fetch_geojson_with_fallbacks(f"{label} copy{i+1}/{samples}", base, variants)
                      gdf = to_gdf(obj)
                      before = len(gdf)
                      gdf = clip_to_nb(gdf)
                      after = len(gdf)
                      counts.append(after)
                      frames.append(gdf)
                      log(f"[INFO] {label}: before_clip={before}, after_clip={after}")
                      time.sleep(0.3)
                  if len(set(counts)) == 1:
                      log(f"[OK] {label}: consensus n={counts[0]}")
                      return frames[0]
                  log(f"[WARN] {label}: mismatch counts {counts}, retrying…")
                  time.sleep(1.2)

              from collections import Counter
              c = Counter(counts)
              n, _ = c.most_common(1)[0]
              idx = counts.index(n)
              log(f"[WARN] {label}: using majority sample n={n}")
              return frames[idx]

          # ---------- Run ----------
          failures = []
          for ds in DATASETS:
              label = f"{ds['group']}/{ds['key']}"
              try:
                  gdf = consensus_download(ds["builder"], label)
                  out_dir = FOLDERS[ds["group"]]
                  out_path = os.path.join(out_dir, f"{ds['key']}_{today_str}.geojson")
                  if os.path.exists(out_path): os.remove(out_path)
                  gdf.to_file(out_path, driver="GeoJSON")
                  log(f"[SAVED] {out_path} ({len(gdf)} features)")
              except Exception as e:
                  failures.append((label, str(e)))
                  log(f"[ERROR] {label}: {e}")

          if failures:
              log("---- FAILURES ----")
              for lbl, err in failures:
                  log(f" - {lbl}: {err}")
              sys.exit(1)
          PYCODE

      - name: Commit and push changes (rebase & retry)
        if: success()
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -xeuo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase true
          git config rebase.autoStash true

          git fetch origin "$BRANCH_NAME"
          git checkout "$BRANCH_NAME"
          git pull --rebase origin "$BRANCH_NAME"

          mkdir -p archive/cwfis archive/erd
          touch archive/.gitkeep
          git add -A archive

          if ! git diff --cached --quiet; then
            git commit -m "Daily fire archive for $(date -u +%Y-%m-%d)"
            for i in 1 2 3 4 5; do
              if git push origin "HEAD:$BRANCH_NAME"; then
                exit 0
              fi
              echo "Push failed (attempt $i). Rebasing & retrying…"
              git fetch origin "$BRANCH_NAME"
              git pull --rebase origin "$BRANCH_NAME" || true
              sleep 2
            done
            echo "Giving up after 5 attempts."
            exit 1
          else
            echo "No changes to commit."
          fi

      - name: Upload archive artifact (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: geojson-archive
          path: archive/**/*.geojson
          if-no-files-found: ignore
