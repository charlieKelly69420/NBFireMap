name: Daily Fire Data Archive

on:
  schedule:
    - cron: "5 * * * *"  # daily ~05:10 America/Toronto
  workflow_dispatch: {}

# Allow the workflow to push back to the repo
permissions:
  contents: write

jobs:
  fetch-and-archive:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ensure we can commit and push cleanly

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install geopandas requests

      - name: Download, validate (5× copies), clip, and write files
        shell: bash
        run: |
          set -euo pipefail
          python <<'PYCODE'
          import json, os, sys, time
          from datetime import datetime
          from zoneinfo import ZoneInfo

          import requests
          import geopandas as gpd
          from shapely.geometry import box

          TZ = ZoneInfo("America/Toronto")
          today_str = datetime.now(TZ).strftime("%Y%m%d")

          ROOT = "archive"
          FOLDERS = {
              "cwfis": os.path.join(ROOT, "cwfis"),
              "erd": os.path.join(ROOT, "erd"),
          }
          for p in FOLDERS.values():
              os.makedirs(p, exist_ok=True)

          # New Brunswick bounding box (WGS84): lon_min, lat_min, lon_max, lat_max
          NB_BBOX = (-69.05, 44.56, -63.70, 48.07)
          nb_poly = box(*NB_BBOX)
          nb_gdf = gpd.GeoDataFrame(geometry=[nb_poly], crs="EPSG:4326")

          DATASETS = [
              # CWFIS via WFS
              {
                  "key": "24_hour_spots",
                  "group": "cwfis",
                  "url": "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/ows"
                         "?service=WFS&version=1.0.0&request=GetFeature"
                         "&typeName=public:hotspots_last24hrs&outputFormat=application/json",
              },
              {
                  "key": "fire_perimeters",
                  "group": "cwfis",
                  "url": "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/ows"
                         "?service=WFS&version=1.0.0&request=GetFeature"
                         "&typeName=public:m3_polygons_current&outputFormat=application/json",
              },
              # ERD (ArcGIS REST → GeoJSON, all fields, WGS84)
              {
                  "key": "active_fires",
                  "group": "erd",
                  "url": "https://gis-erd-der.gnb.ca/arcgis/rest/services/Fire_Dashboards/Public_Fires/MapServer/0/query"
                         "?where=1%3D1&outFields=%2A&f=geojson&outSR=4326",
              },
              {
                  "key": "out_fires",
                  "group": "erd",
                  "url": "https://gis-erd-der.gnb.ca/arcgis/rest/services/Fire_Dashboards/Public_Fires/MapServer/1/query"
                         "?where=1%3D1&outFields=%2A&f=geojson&outSR=4326",
              },
          ]

          def fetch_geojson(url: str) -> dict:
              r = requests.get(url, timeout=60)
              r.raise_for_status()
              return r.json()

          def to_gdf(gj: dict) -> gpd.GeoDataFrame:
              gdf = gpd.GeoDataFrame.from_features(gj.get("features", []), crs="EPSG:4326")
              if gdf.crs is None:
                  gdf.set_crs("EPSG:4326", inplace=True)
              elif gdf.crs.to_string().lower() != "epsg:4326":
                  gdf = gdf.to_crs("EPSG:4326")
              return gdf

          def clip_to_nb(gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
              if gdf.empty:
                  return gdf
              try:
                  gdf = gdf.set_geometry(gdf.geometry.buffer(0))
              except Exception:
                  pass
              return gpd.overlay(gdf, nb_gdf, how="intersection")

          def consensus_download(url: str, label: str, max_rounds=5, samples=5) -> gpd.GeoDataFrame:
              for attempt in range(1, max_rounds + 1):
                  counts, frames = [], []
                  for _ in range(samples):
                      gj = fetch_geojson(url)
                      gdf = clip_to_nb(to_gdf(gj))
                      counts.append(len(gdf))
                      frames.append(gdf)
                      time.sleep(0.5)
                  if len(set(counts)) == 1:
                      print(f"[OK] {label}: consensus (n={counts[0]}) on round {attempt}")
                      return frames[0]
                  print(f"[WARN] {label}: mismatch {counts} on round {attempt}, retrying…")
                  time.sleep(2)

              from collections import Counter
              cnt = Counter(counts)
              majority = cnt.most_common(1)[0][0]
              idx = counts.index(majority)
              print(f"[WARN] {label}: using majority sample (n={majority}) after {max_rounds} rounds.")
              return frames[idx]

          failures = []
          for ds in DATASETS:
              label = f"{ds['group']}/{ds['key']}"
              try:
                  gdf = consensus_download(ds["url"], label)
                  out_dir = FOLDERS[ds["group"]]
                  out_path = os.path.join(out_dir, f"{ds['key']}_{today_str}.geojson")
                  if os.path.exists(out_path):
                      os.remove(out_path)
                  gdf.to_file(out_path, driver="GeoJSON")
                  print(f"[SAVED] {out_path} ({len(gdf)} features)")
              except Exception as e:
                  failures.append((label, str(e)))
                  print(f"[ERROR] {label}: {e}", file=sys.stderr)

          if failures:
              print("\nFailures:", file=sys.stderr)
              for lbl, err in failures:
                  print(f" - {lbl}: {err}", file=sys.stderr)
              sys.exit(1)
          PYCODE

      - name: Commit and push changes
        if: success()
        run: |
          set -euo pipefail
          # Configure bot identity
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage only the archive tree (create if empty to avoid failures)
          mkdir -p archive/cwfis archive/erd
          # Add a .gitkeep so empty dirs are tracked (optional)
          touch archive/.gitkeep
          git add -A archive

          # Commit if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "Daily fire archive for $(date -u +%Y-%m-%d)"
            git push
          else
            echo "No changes to commit."
          fi

      # Optional: also upload as a run artifact for convenience
      - name: Upload archive artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: geojson-archive
          path: archive/**/*.geojson
          if-no-files-found: ignore
